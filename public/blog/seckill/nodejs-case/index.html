<!doctype html>
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="generator" content="Hugo 0.88.1" />
<meta name="robots" content="index, follow">


<link rel="shortcut icon" href="/favicons/favicon.ico" >
<link rel="apple-touch-icon" href="/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="icon" type="image/png" href="/favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/favicons/android-36x36.png" sizes="36x36">
<link rel="icon" type="image/png" href="/favicons/android-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="/favicons/android-72x72.png" sizes="72x72">
<link rel="icon" type="image/png" href="/favicons/android-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/favicons/android-144x144.png" sizes="144x144">
<link rel="icon" type="image/png" href="/favicons/android-192x192.png" sizes="192x192">

<title>Node.js 中实践基于 Redis 的分布式锁实现 | redis-docs</title>
<meta name="description" content="在一些分布式环境下、多线程并发编程中，如果对同一资源进行读写操作，避免不了的一个就是资源竞争问题，通过引入分布式锁这一概念，可以解决数据一致性问题。
作者简介：五月君，Nodejs Developer，慕课网认证作者，热爱技术、喜欢分享的 90 后青年，欢迎关注 Nodejs …">
<meta property="og:title" content="Node.js 中实践基于 Redis 的分布式锁实现" />
<meta property="og:description" content="在一些分布式环境下、多线程并发编程中，如果对同一资源进行读写操作，避免不了的一个就是资源竞争问题，通过引入分布式锁这一概念，可以解决数据一致性问题。
作者简介：五月君，Nodejs Developer，慕课网认证作者，热爱技术、喜欢分享的 90 后青年，欢迎关注 Nodejs 技术栈 和 Github 开源项目 https://www.nodejs.red
认识线程、进程、分布式锁   线程锁：单线程编程模式下请求是顺序的，一个好处是不需要考虑线程安全、资源竞争问题，因此当你进行 Node.js 编程时，也不会去考虑线程安全问题。 那么多线程编程模式下，例如 Java 你可能很熟悉一个词 synchronized，通常也是 Java 中解决并发编程最简单的一种方式， synchronized 可以保证在同一时刻仅有一个线程去执行某个方法或某块代码。
  进程锁：一个服务部署于一台服务器，同时开启多个进程，Node.js 编程中为了利用操作系统资源，根据 CPU 的核心数可以开启多进程模式， 这个时候如果对一个共享资源操作还是会遇到资源竞争问题，另外每一个进程都是相互独立的，拥有自己独立的内存空间。 关于进程锁通过 Java 中的 synchronized 也很难去解决，synchronized 仅局限于在同一个 JVM 中有效。
  分布式锁：一个服务无论是单线程还是多进程模式，当多机部署、处于分布式环境下对同一共享资源进行操作还是会面临同样的问题。 此时就要去引入一个概念分布式锁。 如下图所示，由于先读数据在通过业务逻辑修改之后进行 SET 操作，这并不是一个原子操作，当多个客户端对同一资源进行先读后写操作就会引发并发问题， 这时就要引入分布式锁去解决，通常也是一个很广泛的解决方案。
  基于 Redis 的分布式锁实现思路 实现分布式锁的方式有很多：数据库、Redis、Zookeeper。这里主要介绍的是通过 Redis 来实现一个分布式锁，至少要保证三个特性：安全性、死锁、容错。
 安全性：所谓一个萝卜一个坑，第一点要做的是上锁，在任意时刻要保证仅有一个客户端持有该锁。 死锁：造成死锁可能是由于某种原因，本该释放的锁没有被释放，因此在上锁的时候可以同步的设置过期时间， 如果由于客户端自己的原因没有被释放，也要保证锁能够自动释放。 容错：容错是在多节点的模式下需要考虑的，只要能保证 N/2&#43;1 节点可用，客户端就可以成功获取、释放锁。  Redis 单实例分布式锁实现 在 Redis 的单节点实例下实现一个简单的分布式锁，这里会借助一些简单的 Lua 脚本来实现原子性， 不了解可以参考之前的文章 Node." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/blog/seckill/nodejs-case/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2019-11-24T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-11-24T00:00:00+00:00" />

<meta itemprop="name" content="Node.js 中实践基于 Redis 的分布式锁实现">
<meta itemprop="description" content="在一些分布式环境下、多线程并发编程中，如果对同一资源进行读写操作，避免不了的一个就是资源竞争问题，通过引入分布式锁这一概念，可以解决数据一致性问题。
作者简介：五月君，Nodejs Developer，慕课网认证作者，热爱技术、喜欢分享的 90 后青年，欢迎关注 Nodejs 技术栈 和 Github 开源项目 https://www.nodejs.red
认识线程、进程、分布式锁   线程锁：单线程编程模式下请求是顺序的，一个好处是不需要考虑线程安全、资源竞争问题，因此当你进行 Node.js 编程时，也不会去考虑线程安全问题。 那么多线程编程模式下，例如 Java 你可能很熟悉一个词 synchronized，通常也是 Java 中解决并发编程最简单的一种方式， synchronized 可以保证在同一时刻仅有一个线程去执行某个方法或某块代码。
  进程锁：一个服务部署于一台服务器，同时开启多个进程，Node.js 编程中为了利用操作系统资源，根据 CPU 的核心数可以开启多进程模式， 这个时候如果对一个共享资源操作还是会遇到资源竞争问题，另外每一个进程都是相互独立的，拥有自己独立的内存空间。 关于进程锁通过 Java 中的 synchronized 也很难去解决，synchronized 仅局限于在同一个 JVM 中有效。
  分布式锁：一个服务无论是单线程还是多进程模式，当多机部署、处于分布式环境下对同一共享资源进行操作还是会面临同样的问题。 此时就要去引入一个概念分布式锁。 如下图所示，由于先读数据在通过业务逻辑修改之后进行 SET 操作，这并不是一个原子操作，当多个客户端对同一资源进行先读后写操作就会引发并发问题， 这时就要引入分布式锁去解决，通常也是一个很广泛的解决方案。
  基于 Redis 的分布式锁实现思路 实现分布式锁的方式有很多：数据库、Redis、Zookeeper。这里主要介绍的是通过 Redis 来实现一个分布式锁，至少要保证三个特性：安全性、死锁、容错。
 安全性：所谓一个萝卜一个坑，第一点要做的是上锁，在任意时刻要保证仅有一个客户端持有该锁。 死锁：造成死锁可能是由于某种原因，本该释放的锁没有被释放，因此在上锁的时候可以同步的设置过期时间， 如果由于客户端自己的原因没有被释放，也要保证锁能够自动释放。 容错：容错是在多节点的模式下需要考虑的，只要能保证 N/2&#43;1 节点可用，客户端就可以成功获取、释放锁。  Redis 单实例分布式锁实现 在 Redis 的单节点实例下实现一个简单的分布式锁，这里会借助一些简单的 Lua 脚本来实现原子性， 不了解可以参考之前的文章 Node."><meta itemprop="datePublished" content="2019-11-24T00:00:00+00:00" />
<meta itemprop="dateModified" content="2019-11-24T00:00:00+00:00" />
<meta itemprop="wordCount" content="762">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Node.js 中实践基于 Redis 的分布式锁实现"/>
<meta name="twitter:description" content="在一些分布式环境下、多线程并发编程中，如果对同一资源进行读写操作，避免不了的一个就是资源竞争问题，通过引入分布式锁这一概念，可以解决数据一致性问题。
作者简介：五月君，Nodejs Developer，慕课网认证作者，热爱技术、喜欢分享的 90 后青年，欢迎关注 Nodejs 技术栈 和 Github 开源项目 https://www.nodejs.red
认识线程、进程、分布式锁   线程锁：单线程编程模式下请求是顺序的，一个好处是不需要考虑线程安全、资源竞争问题，因此当你进行 Node.js 编程时，也不会去考虑线程安全问题。 那么多线程编程模式下，例如 Java 你可能很熟悉一个词 synchronized，通常也是 Java 中解决并发编程最简单的一种方式， synchronized 可以保证在同一时刻仅有一个线程去执行某个方法或某块代码。
  进程锁：一个服务部署于一台服务器，同时开启多个进程，Node.js 编程中为了利用操作系统资源，根据 CPU 的核心数可以开启多进程模式， 这个时候如果对一个共享资源操作还是会遇到资源竞争问题，另外每一个进程都是相互独立的，拥有自己独立的内存空间。 关于进程锁通过 Java 中的 synchronized 也很难去解决，synchronized 仅局限于在同一个 JVM 中有效。
  分布式锁：一个服务无论是单线程还是多进程模式，当多机部署、处于分布式环境下对同一共享资源进行操作还是会面临同样的问题。 此时就要去引入一个概念分布式锁。 如下图所示，由于先读数据在通过业务逻辑修改之后进行 SET 操作，这并不是一个原子操作，当多个客户端对同一资源进行先读后写操作就会引发并发问题， 这时就要引入分布式锁去解决，通常也是一个很广泛的解决方案。
  基于 Redis 的分布式锁实现思路 实现分布式锁的方式有很多：数据库、Redis、Zookeeper。这里主要介绍的是通过 Redis 来实现一个分布式锁，至少要保证三个特性：安全性、死锁、容错。
 安全性：所谓一个萝卜一个坑，第一点要做的是上锁，在任意时刻要保证仅有一个客户端持有该锁。 死锁：造成死锁可能是由于某种原因，本该释放的锁没有被释放，因此在上锁的时候可以同步的设置过期时间， 如果由于客户端自己的原因没有被释放，也要保证锁能够自动释放。 容错：容错是在多节点的模式下需要考虑的，只要能保证 N/2&#43;1 节点可用，客户端就可以成功获取、释放锁。  Redis 单实例分布式锁实现 在 Redis 的单节点实例下实现一个简单的分布式锁，这里会借助一些简单的 Lua 脚本来实现原子性， 不了解可以参考之前的文章 Node."/>




<link rel="preload" href="/scss/main.scss" as="style">
<link href="/scss/main.scss" rel="stylesheet" integrity="">

<script
  src="https://code.jquery.com/jquery-3.5.1.min.js"
  integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
  crossorigin="anonymous"></script>

  </head>
  <body class="td-page td-blog">
    <header>
      
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar">
        <a class="navbar-brand" href="/">
		<span class="navbar-logo"></span><span class="text-uppercase font-weight-bold">redis-docs</span>
	</a>
	<div class="td-navbar-nav-scroll ml-md-auto" id="main_navbar">
		<ul class="navbar-nav mt-2 mt-lg-0">
			
			
			<li class="nav-item mr-4 mb-2 mb-lg-0">
				
				
				
				
				
				
				
				
				<a class="nav-link" href="/docs/" ><span>文档</span></a>
			</li>
			
			<li class="nav-item mr-4 mb-2 mb-lg-0">
				
				
				
				
				
				
				
				
				<a class="nav-link active" href="/blog/" ><span class="active">博客</span></a>
			</li>
			
			
			
		</ul>
	</div>
	<div class="navbar-nav d-none d-lg-block"></div>
</nav>

    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <aside class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
            
<div id="td-sidebar-menu" class="td-sidebar__inner">
  <form class="td-sidebar__search d-flex align-items-center">
    
    <button class="btn btn-link td-sidebar__toggle d-md-none p-0 ml-3 fas fa-bars" type="button" data-toggle="collapse" data-target="#td-section-nav" aria-controls="td-docs-nav" aria-expanded="false" aria-label="Toggle section navigation">
    </button>
  </form>
  <nav class="collapse td-sidebar-nav" id="td-section-nav">
    <ul class="td-sidebar-nav__section pr-md-3 ul-0">
      <li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id="m-blog-li">
  <a href="/blog/" class="align-left pl-0 td-sidebar-link td-sidebar-link__section tree-root" id="m-blog"><span class="">博客</span></a>
  <ul class="ul-1">
    <li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id="m-blognews-li">
  <a href="/blog/news/" class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id="m-blognews"><span class="">news</span></a>
  <ul class="ul-2 foldable">
    <li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id="m-blognewslua-li">
  <a href="/blog/news/lua/" class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id="m-blognewslua"><span class="">Lua News</span></a>
  <ul class="ul-3 foldable">
    <li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blognewslua2020-2021-li">
  <a href="/blog/news/lua/2020-2021/" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blognewslua2020-2021"><span class="">2020-2021 Lua News</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blognewslua2010-2019-li">
  <a href="/blog/news/lua/2010-2019/" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blognewslua2010-2019"><span class="">2010-2019 Lua News</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blognewslua2000-2009-li">
  <a href="/blog/news/lua/2000-2009/" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blognewslua2000-2009"><span class="">2000-2009 Lua News</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blognewslua1993-1999-li">
  <a href="/blog/news/lua/1993-1999/" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blognewslua1993-1999"><span class="">1993-1999 Lua News</span></a>
</li>
  </ul>
</li>
  </ul>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id="m-blogseckill-li">
  <a href="/blog/seckill/" class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id="m-blogseckill"><span class="">秒杀</span></a>
  <ul class="ul-2 foldable">
    <li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blogseckillredlock-system-awareness-li">
  <a href="/blog/seckill/redlock-system-awareness/" title="建立对分布式锁的系统认知 - 从 Redlock 开始" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blogseckillredlock-system-awareness"><span class="">分布式锁系统认知</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blogseckillimplementation-of-redis-distributed-lock-li">
  <a href="/blog/seckill/implementation-of-redis-distributed-lock/" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blogseckillimplementation-of-redis-distributed-lock"><span class="">Implementation of redis distributed lock</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blogseckillexample-li">
  <a href="/blog/seckill/example/" title="一个使用 Node.js 的 Redlock 示例，关于如何锁定一个Redis上的密钥对" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blogseckillexample"><span class="">Redlok 示例</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blogseckillreplace_setnx-li">
  <a href="/blog/seckill/replace_setnx/" title="Redis 使用 Lua 脚本替代 SETNX / DECR 保证原子性" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blogseckillreplace_setnx"><span class="">替代 SETNX/DECR</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child active-path" id="m-blogseckillnodejs-case-li">
  <a href="/blog/seckill/nodejs-case/" title="Node.js 中实践基于 Redis 的分布式锁实现" class="align-left pl-0 active td-sidebar-link td-sidebar-link__page" id="m-blogseckillnodejs-case"><span class="td-sidebar-nav-active-item">分布式锁实现</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blogseckillnodejs-redis-lua-li">
  <a href="/blog/seckill/nodejs-redis-lua/" title="Node.js 中实践 Redis Lua 脚本" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blogseckillnodejs-redis-lua"><span class="">Node.js Redis Lua</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blogseckillis_redlock_safe-li">
  <a href="/blog/seckill/is_redlock_safe/" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blogseckillis_redlock_safe"><span class="">Is Redlock safe?</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blogseckilldistlock-li">
  <a href="/blog/seckill/distlock/" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blogseckilldistlock"><span class="">Redis分布式锁</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blogseckillhow-to-do-distributed-locking-li">
  <a href="/blog/seckill/how-to-do-distributed-locking/" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blogseckillhow-to-do-distributed-locking"><span class="">How to do distributed locking</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blogseckillredis_lua-li">
  <a href="/blog/seckill/redis_lua/" title="Redis&#43;Lua 解决高并发场景抢购秒杀问题" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blogseckillredis_lua"><span class="">Redis&#43;Lua秒杀</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blogseckilldistlock-cn-li">
  <a href="/blog/seckill/distlock-cn/" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blogseckilldistlock-cn"><span class="">Redis分布式锁</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blogseckillaliyun-li">
  <a href="/blog/seckill/aliyun/" title="使用  搭建电商秒杀系统" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blogseckillaliyun"><span class="">Redis秒杀系统</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blogseckillredlock-controversy-li">
  <a href="/blog/seckill/redlock-controversy/" title="Redis Redlock 的争论" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blogseckillredlock-controversy"><span class="">Redlock 争论</span></a>
</li>
  </ul>
</li>
  </ul>
</li>
    </ul>
  </nav>
</div>

          </aside>
          <aside class="d-none d-xl-block col-xl-2 td-sidebar-toc d-print-none">
            
<div class="td-page-meta ml-2 pb-1 pt-2 mb-0">

</div>

            


<div class="td-toc"><nav id="TableOfContents">
  <ul>
    <li><a href="#认识线程进程分布式锁">认识线程、进程、分布式锁</a></li>
    <li><a href="#基于-redis-的分布式锁实现思路">基于 Redis 的分布式锁实现思路</a></li>
    <li><a href="#redis-单实例分布式锁实现">Redis 单实例分布式锁实现</a>
      <ul>
        <li><a href="#上锁">上锁</a></li>
        <li><a href="#释放锁">释放锁</a></li>
      </ul>
    </li>
    <li><a href="#nodejs-单实例分布式锁实践">Node.js 单实例分布式锁实践</a>
      <ul>
        <li><a href="#初始化自定义-redislock">初始化自定义 RedisLock</a></li>
        <li><a href="#上锁-1">上锁</a></li>
        <li><a href="#释放锁-1">释放锁</a></li>
        <li><a href="#测试">测试</a></li>
        <li><a href="#源码地址">源码地址</a></li>
      </ul>
    </li>
    <li><a href="#redlock-算法">Redlock 算法</a>
      <ul>
        <li><a href="#redlock-介绍">Redlock 介绍</a></li>
        <li><a href="#nodejs-中应用-redlock">Node.js 中应用 Redlock</a></li>
        <li><a href="#编码">编码</a></li>
        <li><a href="#测试-1">测试</a></li>
      </ul>
    </li>
  </ul>
</nav></div>



            

	
		



  
  

	
		



  
  

	

          </aside>
          <main class="col-12 col-md-9 col-xl-8 pl-md-5 pr-md-4" role="main">
            <a class="btn btn-lg -bg-orange td-rss-button d-none d-lg-block" href="http://example.org/blog/seckill/index.xml" target="_blank">
              RSS <i class="fa fa-rss ml-2 "></i>
            </a>
            
<div class="td-content">
	<h1>Node.js 中实践基于 Redis 的分布式锁实现</h1>
	
	<div class="td-byline mb-4">
		By <b>五月君</b> |
		<time datetime="2019-11-24" class="text-muted">Sunday, November 24, 2019</time>
	</div>
	<header class="article-meta">
		
		
			
				


			
				


			
		
		
	</header>
	<p>在一些分布式环境下、多线程并发编程中，如果对同一资源进行读写操作，避免不了的一个就是资源竞争问题，通过引入分布式锁这一概念，可以解决数据一致性问题。</p>
<p>作者简介：五月君，Nodejs Developer，慕课网认证作者，热爱技术、喜欢分享的 90 后青年，欢迎关注 Nodejs 技术栈 和 Github 开源项目 <a href="https://www.nodejs.red">https://www.nodejs.red</a></p>
<h2 id="认识线程进程分布式锁">认识线程、进程、分布式锁</h2>
<ul>
<li>
<p><strong>线程锁</strong>：单线程编程模式下请求是顺序的，一个好处是不需要考虑线程安全、资源竞争问题，因此当你进行 Node.js 编程时，也不会去考虑线程安全问题。
那么多线程编程模式下，例如 Java 你可能很熟悉一个词 synchronized，通常也是 Java 中解决并发编程最简单的一种方式，
synchronized 可以保证在同一时刻仅有一个线程去执行某个方法或某块代码。</p>
</li>
<li>
<p><strong>进程锁</strong>：一个服务部署于一台服务器，同时开启多个进程，Node.js 编程中为了利用操作系统资源，根据 CPU 的核心数可以开启多进程模式，
这个时候如果对一个共享资源操作还是会遇到资源竞争问题，另外每一个进程都是相互独立的，拥有自己独立的内存空间。
关于进程锁通过 Java 中的 synchronized 也很难去解决，synchronized 仅局限于在同一个 JVM 中有效。</p>
</li>
<li>
<p><strong>分布式锁</strong>：一个服务无论是单线程还是多进程模式，当多机部署、处于分布式环境下对同一共享资源进行操作还是会面临同样的问题。
此时就要去引入一个概念分布式锁。
如下图所示，由于先读数据在通过业务逻辑修改之后进行 SET 操作，这并不是一个原子操作，当多个客户端对同一资源进行先读后写操作就会引发并发问题，
这时就要引入分布式锁去解决，通常也是一个很广泛的解决方案。</p>
<p><img src="https://pic2.zhimg.com/80/v2-d7b830fc4d16750723645db7edb22ff1_1440w.jpg" alt=""></p>
</li>
</ul>
<h2 id="基于-redis-的分布式锁实现思路">基于 Redis 的分布式锁实现思路</h2>
<p>实现分布式锁的方式有很多：数据库、Redis、Zookeeper。这里主要介绍的是通过 Redis 来实现一个分布式锁，至少要保证三个特性：安全性、死锁、容错。</p>
<ul>
<li><strong>安全性</strong>：所谓一个萝卜一个坑，第一点要做的是上锁，在任意时刻要保证仅有一个客户端持有该锁。</li>
<li><strong>死锁</strong>：造成死锁可能是由于某种原因，本该释放的锁没有被释放，因此在上锁的时候可以同步的设置过期时间，
如果由于客户端自己的原因没有被释放，也要保证锁能够自动释放。</li>
<li><strong>容错</strong>：容错是在多节点的模式下需要考虑的，只要能保证 N/2+1 节点可用，客户端就可以成功获取、释放锁。</li>
</ul>
<h2 id="redis-单实例分布式锁实现">Redis 单实例分布式锁实现</h2>
<p>在 Redis 的单节点实例下实现一个简单的分布式锁，这里会借助一些简单的 Lua 脚本来实现原子性，
不了解可以参考之前的文章 <a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/kfgiVkKZofLh6qiqUd48Cw">Node.js 中实践 Redis Lua 脚本</a></p>
<h3 id="上锁">上锁</h3>
<p>上锁的第一步就是先通过 <code>setnx</code> 命令占坑，为了防止死锁，通常在占坑之后还会设置一个过期时间 <code>expire</code>，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">setnx key value
expire key seconds
</code></pre></div><p>以上命令不是一个原子性操作，所谓原子性操作是指命令在执行过程中并不会被其它的线程或者请求打断，
以上如果 setnx 执行成功之后，出现网络闪断 <code>expire</code> 命令便不会得到执行，会导致死锁出现。</p>
<p>也许你会想到使用事物来解决，但是事物有个特点，要么成功要么失败，都是一口气执行完成的，
在我们上面的例子中，<code>expire</code> 是需要先根据 <code>setnx</code> 的结果来判断是否需要进行设置，
显然事物在这里是行不通的，社区也有很多库来解决这个问题，
现在 Redis 官方 2.8 版本之后支持 <code>set</code> 命令传入 <code>setnx</code>、<code>expire</code> 扩展参数，这样就可以一条命令一口气执行，避免了上面的问题，如下所示：</p>
<ul>
<li><strong>value</strong>：建议设置为一个随机值，在释放锁的时候会进一步讲解</li>
<li><strong>EX seconds</strong>：设置的过期时间</li>
<li><strong>PX milliseconds</strong>：也是设置过期时间，单位不一样</li>
<li><strong>NX|XX</strong>：NX 同 setnx 效果是一样的</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">set key value <span style="color:#f92672">[</span>EX seconds<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>PX milliseconds<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>NX|XX<span style="color:#f92672">]</span>
</code></pre></div><h3 id="释放锁">释放锁</h3>
<p>释放锁的过程就是将原本占有的坑给删除掉，但是也并不能仅仅使用 <code>del key</code> 删除掉就万事大吉了，
这样很容易删除掉别人的锁，为什么呢？举一个例子客户端 A 获取到一把 <code>key = name1</code> 的锁（2 秒中），
紧接着处理自己的业务逻辑，但是在业务逻辑处理这块阻塞了耗时超过了锁的时间，锁是会自动被释放的，
这期间该资源又被客户端 B 获取了 <code>key = name1</code> 的锁，那么客户端 A 在自己的业务处理结束之后直接使用 del key 命令删除会把客户端 B 的锁给释放掉了，
所以释放锁的时候要做到仅释放自己占有的锁。</p>
<p>加锁的过程中建议把 value 设置为一个随机值，主要是为了更安全的释放锁，在 <code>del key</code> 之前先判断这个 key 存在且 value 等于自己指定的值才执行删除操作。
判断和删除不是一个原子性的操作，此处仍需借助 Lua 脚本实现。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">if</span> redis.call(<span style="color:#e6db74">&#34;get&#34;</span>,KEYS[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">==</span> ARGV[<span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span> redis.call(<span style="color:#e6db74">&#34;del&#34;</span>,KEYS[<span style="color:#ae81ff">1</span>])
<span style="color:#66d9ef">else</span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><h2 id="nodejs-单实例分布式锁实践">Node.js 单实例分布式锁实践</h2>
<p>Redis 单实例分布式锁 Node.js 实践</p>
<p>使用 Node.js 的 Redis 客户端为 ioredis，<code>npm install ioredis -S</code> 先安装该包。</p>
<h3 id="初始化自定义-redislock">初始化自定义 RedisLock</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RedisLock</span> {
  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * 初始化 RedisLock
</span><span style="color:#75715e">   * @param {*} client
</span><span style="color:#75715e">   * @param {*} options
</span><span style="color:#75715e">   */</span>
  <span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">client</span>, <span style="color:#a6e22e">options</span> <span style="color:#f92672">=</span> {}) {
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">client</span>) {
      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">&#34;client 不存在&#34;</span>);
    }

    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">!==</span> <span style="color:#e6db74">&#34;connecting&#34;</span>) {
      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">&#34;client 未正常链接&#34;</span>);
    }

    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lockLeaseTime</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">lockLeaseTime</span> <span style="color:#f92672">||</span> <span style="color:#ae81ff">2</span>; <span style="color:#75715e">// 默认锁过期时间 2 秒
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lockTimeout</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">lockTimeout</span> <span style="color:#f92672">||</span> <span style="color:#ae81ff">5</span>; <span style="color:#75715e">// 默认锁超时时间 5 秒
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">expiryMode</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">expiryMode</span> <span style="color:#f92672">||</span> <span style="color:#e6db74">&#34;EX&#34;</span>;
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">setMode</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">setMode</span> <span style="color:#f92672">||</span> <span style="color:#e6db74">&#34;NX&#34;</span>;
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">client</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">client</span>;
  }
}
</code></pre></div><h3 id="上锁-1">上锁</h3>
<p>通过 set 命令传入 setnx、expire 扩展参数开始上锁占坑，上锁成功返回，上锁失败进行重试，在 <code>lockTimeout</code> 指定时间内仍未获取到锁，则获取锁失败。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RedisLock</span> {
  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * 上锁
</span><span style="color:#75715e">   * @param {*} key
</span><span style="color:#75715e">   * @param {*} val
</span><span style="color:#75715e">   * @param {*} expire
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">async</span> <span style="color:#a6e22e">lock</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">val</span>, <span style="color:#a6e22e">expire</span>) {
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">start</span> <span style="color:#f92672">=</span> Date.<span style="color:#a6e22e">now</span>();
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">self</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>;

    <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">intranetLock</span>() {
      <span style="color:#66d9ef">try</span> {
        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">self</span>.<span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">set</span>(
          <span style="color:#a6e22e">key</span>,
          <span style="color:#a6e22e">val</span>,
          <span style="color:#a6e22e">self</span>.<span style="color:#a6e22e">expiryMode</span>,
          <span style="color:#a6e22e">expire</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">self</span>.<span style="color:#a6e22e">lockLeaseTime</span>,
          <span style="color:#a6e22e">self</span>.<span style="color:#a6e22e">setMode</span>
        );

        <span style="color:#75715e">// 上锁成功
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">result</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;OK&#34;</span>) {
          <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">key</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">val</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> 上锁成功`</span>);
          <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
        }

        <span style="color:#75715e">// 锁超时
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (Math.<span style="color:#a6e22e">floor</span>((Date.<span style="color:#a6e22e">now</span>() <span style="color:#f92672">-</span> <span style="color:#a6e22e">start</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">1000</span>) <span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">self</span>.<span style="color:#a6e22e">lockTimeout</span>) {
          <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">key</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">val</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> 上锁重试超时结束`</span>);
          <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
        }

        <span style="color:#75715e">// 循环等待重试
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">key</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">val</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> 等待重试`</span>);
        <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">sleep</span>(<span style="color:#ae81ff">3000</span>);
        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">key</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">val</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> 开始重试`</span>);

        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">intranetLock</span>();
      } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">err</span>) {
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#a6e22e">err</span>);
      }
    })();
  }
}
</code></pre></div><h3 id="释放锁-1">释放锁</h3>
<p>释放锁通过 <code>redis.eval(script)</code> 执行我们定义的 redis lua 脚本。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RedisLock</span> {
  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * 释放锁
</span><span style="color:#75715e">   * @param {*} key
</span><span style="color:#75715e">   * @param {*} val
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">async</span> <span style="color:#a6e22e">unLock</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">val</span>) {
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">self</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>;
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">script</span> <span style="color:#f92672">=</span>
      <span style="color:#e6db74">&#34;if redis.call(&#39;get&#39;,KEYS[1]) == ARGV[1] then&#34;</span> <span style="color:#f92672">+</span>
      <span style="color:#e6db74">&#34;   return redis.call(&#39;del&#39;,KEYS[1]) &#34;</span> <span style="color:#f92672">+</span>
      <span style="color:#e6db74">&#34;else&#34;</span> <span style="color:#f92672">+</span>
      <span style="color:#e6db74">&#34;   return 0 &#34;</span> <span style="color:#f92672">+</span>
      <span style="color:#e6db74">&#34;end&#34;</span>;

    <span style="color:#66d9ef">try</span> {
      <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">self</span>.<span style="color:#a6e22e">client</span>.eval(<span style="color:#a6e22e">script</span>, <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">val</span>);

      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">result</span> <span style="color:#f92672">===</span> <span style="color:#ae81ff">1</span>) {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
      }

      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
    } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">err</span>) {
      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#a6e22e">err</span>);
    }
  }
}
</code></pre></div><h3 id="测试">测试</h3>
<p>这里使用了 uuid 来生成唯一 ID，这个随机数 id 只要保证唯一不管用哪种方式都可。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">Redis</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#34;ioredis&#34;</span>);
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">redis</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Redis</span>(<span style="color:#ae81ff">6379</span>, <span style="color:#e6db74">&#34;127.0.0.1&#34;</span>);
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">uuidv1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#34;uuid/v1&#34;</span>);
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">redisLock</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">RedisLock</span>(<span style="color:#a6e22e">redis</span>);

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">sleep</span>(<span style="color:#a6e22e">time</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>) =&gt; {
    <span style="color:#a6e22e">setTimeout</span>(<span style="color:#66d9ef">function</span> () {
      <span style="color:#a6e22e">resolve</span>();
    }, <span style="color:#a6e22e">time</span> <span style="color:#f92672">||</span> <span style="color:#ae81ff">1000</span>);
  });
}

<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">key</span>) {
  <span style="color:#66d9ef">try</span> {
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">id</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">uuidv1</span>();
    <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">redisLock</span>.<span style="color:#a6e22e">lock</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">id</span>, <span style="color:#ae81ff">20</span>);
    <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">sleep</span>(<span style="color:#ae81ff">3000</span>);

    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">unLock</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">redisLock</span>.<span style="color:#a6e22e">unLock</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">id</span>);
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;unLock: &#34;</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">id</span>, <span style="color:#a6e22e">unLock</span>);
  } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">err</span>) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;上锁失败&#34;</span>, <span style="color:#a6e22e">err</span>);
  }
}

<span style="color:#a6e22e">test</span>(<span style="color:#e6db74">&#34;name1&#34;</span>);
<span style="color:#a6e22e">test</span>(<span style="color:#e6db74">&#34;name1&#34;</span>);
</code></pre></div><p>同时调用了两次 test 方法进行上锁，只有第一个是成功的，
第二个 name1 26e02970-0532-11ea-b978-2160dffafa30 上锁的时候发现 <code>key = name1</code> 已被占坑，
开始重试，由于以上测试中设置了 3 秒钟之后自动释放锁，name1 26e02970-0532-11ea-b978-2160dffafa30 在经过两次重试之后上锁成功。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">name1</span> <span style="color:#ae81ff">26e00260</span><span style="color:#f92672">-</span><span style="color:#ae81ff">0532</span><span style="color:#f92672">-</span><span style="color:#ae81ff">11</span><span style="color:#a6e22e">ea</span><span style="color:#f92672">-</span><span style="color:#a6e22e">b978</span><span style="color:#f92672">-</span><span style="color:#ae81ff">2160</span><span style="color:#a6e22e">dffafa30</span> <span style="color:#a6e22e">上锁成功</span>
<span style="color:#a6e22e">name1</span> <span style="color:#ae81ff">26e02970</span><span style="color:#f92672">-</span><span style="color:#ae81ff">0532</span><span style="color:#f92672">-</span><span style="color:#ae81ff">11</span><span style="color:#a6e22e">ea</span><span style="color:#f92672">-</span><span style="color:#a6e22e">b978</span><span style="color:#f92672">-</span><span style="color:#ae81ff">2160</span><span style="color:#a6e22e">dffafa30</span> <span style="color:#a6e22e">等待重试</span>
<span style="color:#a6e22e">name1</span> <span style="color:#ae81ff">26e02970</span><span style="color:#f92672">-</span><span style="color:#ae81ff">0532</span><span style="color:#f92672">-</span><span style="color:#ae81ff">11</span><span style="color:#a6e22e">ea</span><span style="color:#f92672">-</span><span style="color:#a6e22e">b978</span><span style="color:#f92672">-</span><span style="color:#ae81ff">2160</span><span style="color:#a6e22e">dffafa30</span> <span style="color:#a6e22e">开始重试</span>
<span style="color:#a6e22e">name1</span> <span style="color:#ae81ff">26e02970</span><span style="color:#f92672">-</span><span style="color:#ae81ff">0532</span><span style="color:#f92672">-</span><span style="color:#ae81ff">11</span><span style="color:#a6e22e">ea</span><span style="color:#f92672">-</span><span style="color:#a6e22e">b978</span><span style="color:#f92672">-</span><span style="color:#ae81ff">2160</span><span style="color:#a6e22e">dffafa30</span> <span style="color:#a6e22e">等待重试</span>
<span style="color:#a6e22e">unLock</span><span style="color:#f92672">:</span>  <span style="color:#a6e22e">name1</span> <span style="color:#ae81ff">26e00260</span><span style="color:#f92672">-</span><span style="color:#ae81ff">0532</span><span style="color:#f92672">-</span><span style="color:#ae81ff">11</span><span style="color:#a6e22e">ea</span><span style="color:#f92672">-</span><span style="color:#a6e22e">b978</span><span style="color:#f92672">-</span><span style="color:#ae81ff">2160</span><span style="color:#a6e22e">dffafa30</span> <span style="color:#66d9ef">true</span>
<span style="color:#a6e22e">name1</span> <span style="color:#ae81ff">26e02970</span><span style="color:#f92672">-</span><span style="color:#ae81ff">0532</span><span style="color:#f92672">-</span><span style="color:#ae81ff">11</span><span style="color:#a6e22e">ea</span><span style="color:#f92672">-</span><span style="color:#a6e22e">b978</span><span style="color:#f92672">-</span><span style="color:#ae81ff">2160</span><span style="color:#a6e22e">dffafa30</span> <span style="color:#a6e22e">开始重试</span>
<span style="color:#a6e22e">name1</span> <span style="color:#ae81ff">26e02970</span><span style="color:#f92672">-</span><span style="color:#ae81ff">0532</span><span style="color:#f92672">-</span><span style="color:#ae81ff">11</span><span style="color:#a6e22e">ea</span><span style="color:#f92672">-</span><span style="color:#a6e22e">b978</span><span style="color:#f92672">-</span><span style="color:#ae81ff">2160</span><span style="color:#a6e22e">dffafa30</span> <span style="color:#a6e22e">上锁成功</span>
<span style="color:#a6e22e">unLock</span><span style="color:#f92672">:</span>  <span style="color:#a6e22e">name1</span> <span style="color:#ae81ff">26e02970</span><span style="color:#f92672">-</span><span style="color:#ae81ff">0532</span><span style="color:#f92672">-</span><span style="color:#ae81ff">11</span><span style="color:#a6e22e">ea</span><span style="color:#f92672">-</span><span style="color:#a6e22e">b978</span><span style="color:#f92672">-</span><span style="color:#ae81ff">2160</span><span style="color:#a6e22e">dffafa30</span> <span style="color:#66d9ef">true</span>
</code></pre></div><h3 id="源码地址">源码地址</h3>
<p><a href="https://github.com/Q-Angelo/project-training/tree/master/redis/lock/redislock.js">https://github.com/Q-Angelo/project-training/tree/master/redis/lock/redislock.js</a></p>
<h2 id="redlock-算法">Redlock 算法</h2>
<p>以上是使用 Node.js 对 Redis 分布式锁的一个简单实现，在单实例中是可用的，当我们对 Redis 节点做一个扩展，在 Sentinel、Redis Cluster 下会怎么样呢？</p>
<p>以下是一个 Redis Sentinel 的故障自动转移示例图，假设我们客户端 A 在主节点 192.168.6.128 获取到锁之后，
主节点还未来得及同步信息到从节点就挂掉了，这时候 Sentinel 会选举另外一个从节点做为主节点，
那么客户端 B 此时也来申请相同的锁，就会出现同样一把锁被多个客户端持有，对数据的最终一致性有很高的要求还是不行的。</p>
<p><img src="https://pic3.zhimg.com/80/v2-4228ddede37354ed1e69bf388987647e_1440w.jpg" alt=""></p>
<h3 id="redlock-介绍">Redlock 介绍</h3>
<p>鉴于这些问题，Redis 官网 redis.io/topics/distlock 提供了一个使用 Redis 实现分布式锁的规范算法 Redlock，
中文翻译版参考 <a href="http://redis.cn/topics/distlock.html">http://redis.cn/topics/distlock.html</a></p>
<p>Redlock 在上述文档也有描述，这里简单做个总结：Redlock 在 Redis 单实例或多实例中提供了强有力的保障，
本身具备容错能力，它会从 N 个实例使用相同的 key、随机值尝试 <code>set key value [EX seconds] [PX milliseconds] [NX|XX]</code> 命令去获取锁，
在有效时间内至少 N/2+1 个 Redis 实例取到锁，此时就认为取锁成功，否则取锁失败，失败情况下客户端应该在所有的 Redis 实例上进行解锁。</p>
<h3 id="nodejs-中应用-redlock">Node.js 中应用 Redlock</h3>
<p><a href="https://github.com/mike-marcacci/node-redlock">node-redlock</a> 是 Node.js 版的 Redlock 实现，
使用起来也很简单，开始之前先安装 ioredis、redlock 包。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">npm i ioredis -S
npm i redlock -S
</code></pre></div><h3 id="编码">编码</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">Redis</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#34;ioredis&#34;</span>);
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">client1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Redis</span>(<span style="color:#ae81ff">6379</span>, <span style="color:#e6db74">&#34;127.0.0.1&#34;</span>);
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">Redlock</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#34;redlock&#34;</span>);
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">redlock</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Redlock</span>([<span style="color:#a6e22e">client1</span>], {
  <span style="color:#a6e22e">retryDelay</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">200</span>, <span style="color:#75715e">// time in ms
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">retryCount</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">5</span>,
});

<span style="color:#75715e">// 多个 Redis 实例
</span><span style="color:#75715e">// const redlock = new Redlock(
</span><span style="color:#75715e">//     [new Redis(6379, &#34;127.0.0.1&#34;), new Redis(6379, &#34;127.0.0.2&#34;), new Redis(6379, &#34;127.0.0.3&#34;)],
</span><span style="color:#75715e">// )
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">ttl</span>, <span style="color:#a6e22e">client</span>) {
  <span style="color:#66d9ef">try</span> {
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">lock</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">redlock</span>.<span style="color:#a6e22e">lock</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">ttl</span>);

    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">client</span>, <span style="color:#a6e22e">lock</span>.<span style="color:#a6e22e">value</span>);
    <span style="color:#75715e">// do something ...
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// return lock.unlock();
</span><span style="color:#75715e"></span>  } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">err</span>) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">error</span>(<span style="color:#a6e22e">client</span>, <span style="color:#a6e22e">err</span>);
  }
}

<span style="color:#a6e22e">test</span>(<span style="color:#e6db74">&#34;name1&#34;</span>, <span style="color:#ae81ff">10000</span>, <span style="color:#e6db74">&#34;client1&#34;</span>);
<span style="color:#a6e22e">test</span>(<span style="color:#e6db74">&#34;name1&#34;</span>, <span style="color:#ae81ff">10000</span>, <span style="color:#e6db74">&#34;client2&#34;</span>);
</code></pre></div><h3 id="测试-1">测试</h3>
<p>对同一个 key name1 两次上锁，由于 client1 先取到了锁，client2 无法获取锁，
重试 5 次之后报错 LockError: Exceeded 5 attempts to lock the resource &ldquo;name1&rdquo;.</p>
<p><img src="https://pic2.zhimg.com/80/v2-419f20f85e7f078025724d52c32b8d91_1440w.jpg" alt=""></p>

	

	<ul class="list-unstyled d-flex justify-content-between align-items-center mb-0 pt-5">
  <li>
    <a href="/blog/seckill/nodejs-redis-lua/" aria-label="Previous - Node.js 中实践 Redis Lua 脚本" class="btn btn-primary"><span class="mr-1">←</span>Previous</a>
  </li>
    <a href="/blog/seckill/replace_setnx/" aria-label="Next - Redis 使用 Lua 脚本替代 SETNX / DECR 保证原子性" class="btn btn-primary">Next<span class="ml-1">→</span></a>
  </li>
</ul>

</div>


          </main>
        </div>
      </div>
      
<footer class="bg-dark py-5 row d-print-none">
  <div class="container-fluid mx-sm-5">
    <div class="row">
      <div class="col-6 col-sm-4 text-xs-center order-sm-2">
        
      </div>
      <div class="col-6 col-sm-4 text-right text-xs-center order-sm-3">
        
      </div>
      <div class="col-12 col-sm-4 text-center py-2 order-sm-2">
        
        
	
		<p class="mt-2"><a href="/docs/lua/about/">关于</a></p>
	
      </div>
    </div>
  </div>
</footer>


    </div>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"
    integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN"
    crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js"
    integrity="sha512-UR25UO94eTnCVwjbXozyeVd6ZqpaAE9naiEUBK/A+QDbfSTQFhPGj5lOR6d8tsgbBk84Ggb5A3EkjsOgPRPcKA=="
    crossorigin="anonymous"></script>





<script src='/js/tabpane-persist.js'></script>


















<script src="/js/main.min.5c6c35925cba6ccdfc94d3ef0a1ff539934a08075c0931f2c9ab70249877b310.js" integrity="sha256-XGw1kly6bM38lNPvCh/1OZNKCAdcCTHyyatwJJh3sxA=" crossorigin="anonymous"></script>




  </body>
</html>