<!doctype html>
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="generator" content="Hugo 0.88.1" />
<meta name="robots" content="index, follow">


<link rel="shortcut icon" href="/favicons/favicon.ico" >
<link rel="apple-touch-icon" href="/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="icon" type="image/png" href="/favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/favicons/android-36x36.png" sizes="36x36">
<link rel="icon" type="image/png" href="/favicons/android-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="/favicons/android-72x72.png" sizes="72x72">
<link rel="icon" type="image/png" href="/favicons/android-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/favicons/android-144x144.png" sizes="144x144">
<link rel="icon" type="image/png" href="/favicons/android-192x192.png" sizes="192x192">

<title>Node.js 中实践 Redis Lua 脚本 | redis-docs</title>
<meta name="description" content="
https://cloud.tencent.com/developer/article/1536299

Lua 是一种轻量小巧的脚本语言，用标准 C 语言编写并以源代码形式开放，其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。
由于 Lua 语言具备原子性，其在执行的过程 …">
<meta property="og:title" content="Node.js 中实践 Redis Lua 脚本" />
<meta property="og:description" content="https://cloud.tencent.com/developer/article/1536299
 Lua 是一种轻量小巧的脚本语言，用标准 C 语言编写并以源代码形式开放，其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。 由于 Lua 语言具备原子性，其在执行的过程中不会被其它程序打断，对于并发下数据的一致性是有帮助的。
Redis 的两种 Lua 脚本 Redis 支持两种运行 Lua 脚本的方式，一种是直接在 Redis 中输入 Lua 代码，适合于一些简单的脚本。另一种方式是编写 Lua 脚本文件，适合于有逻辑运算的情况，Redis 使用 SHA1 算法支持对脚本签名和 Script Load 预先缓存，需要运行的时候通过签名返回的标识符即可。
下面会分别介绍如何应用 Redis 提供的 EVAL、EVALSHA 两个命令来实现对 Lua 脚本的应用，同时介绍一些在 Node.js 中该如何去应用 Redis 的 Lua 脚本。
EVAL Redis 2.6.0 版本开始，通过内置的 Lua 解释器，可以使用 EVAL 命令对 Lua 脚本进行求值
 script：执行的脚本 numkeys：指定键名参数个数 key：键名，可以多个（key1、key2），通过 KEYS[1] KEYS[2] 的形式访问 atg：键值，可以多个（val1、val2），通过 ARGS[1] ARGS[2] 的形式访问  EVAL script numkeys key [key ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/blog/seckill/nodejs-redis-lua/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2019-11-10T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-11-10T00:00:00+00:00" />

<meta itemprop="name" content="Node.js 中实践 Redis Lua 脚本">
<meta itemprop="description" content="https://cloud.tencent.com/developer/article/1536299
 Lua 是一种轻量小巧的脚本语言，用标准 C 语言编写并以源代码形式开放，其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。 由于 Lua 语言具备原子性，其在执行的过程中不会被其它程序打断，对于并发下数据的一致性是有帮助的。
Redis 的两种 Lua 脚本 Redis 支持两种运行 Lua 脚本的方式，一种是直接在 Redis 中输入 Lua 代码，适合于一些简单的脚本。另一种方式是编写 Lua 脚本文件，适合于有逻辑运算的情况，Redis 使用 SHA1 算法支持对脚本签名和 Script Load 预先缓存，需要运行的时候通过签名返回的标识符即可。
下面会分别介绍如何应用 Redis 提供的 EVAL、EVALSHA 两个命令来实现对 Lua 脚本的应用，同时介绍一些在 Node.js 中该如何去应用 Redis 的 Lua 脚本。
EVAL Redis 2.6.0 版本开始，通过内置的 Lua 解释器，可以使用 EVAL 命令对 Lua 脚本进行求值
 script：执行的脚本 numkeys：指定键名参数个数 key：键名，可以多个（key1、key2），通过 KEYS[1] KEYS[2] 的形式访问 atg：键值，可以多个（val1、val2），通过 ARGS[1] ARGS[2] 的形式访问  EVAL script numkeys key [key ."><meta itemprop="datePublished" content="2019-11-10T00:00:00+00:00" />
<meta itemprop="dateModified" content="2019-11-10T00:00:00+00:00" />
<meta itemprop="wordCount" content="542">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Node.js 中实践 Redis Lua 脚本"/>
<meta name="twitter:description" content="https://cloud.tencent.com/developer/article/1536299
 Lua 是一种轻量小巧的脚本语言，用标准 C 语言编写并以源代码形式开放，其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。 由于 Lua 语言具备原子性，其在执行的过程中不会被其它程序打断，对于并发下数据的一致性是有帮助的。
Redis 的两种 Lua 脚本 Redis 支持两种运行 Lua 脚本的方式，一种是直接在 Redis 中输入 Lua 代码，适合于一些简单的脚本。另一种方式是编写 Lua 脚本文件，适合于有逻辑运算的情况，Redis 使用 SHA1 算法支持对脚本签名和 Script Load 预先缓存，需要运行的时候通过签名返回的标识符即可。
下面会分别介绍如何应用 Redis 提供的 EVAL、EVALSHA 两个命令来实现对 Lua 脚本的应用，同时介绍一些在 Node.js 中该如何去应用 Redis 的 Lua 脚本。
EVAL Redis 2.6.0 版本开始，通过内置的 Lua 解释器，可以使用 EVAL 命令对 Lua 脚本进行求值
 script：执行的脚本 numkeys：指定键名参数个数 key：键名，可以多个（key1、key2），通过 KEYS[1] KEYS[2] 的形式访问 atg：键值，可以多个（val1、val2），通过 ARGS[1] ARGS[2] 的形式访问  EVAL script numkeys key [key ."/>




<link rel="preload" href="/scss/main.scss" as="style">
<link href="/scss/main.scss" rel="stylesheet" integrity="">

<script
  src="https://code.jquery.com/jquery-3.5.1.min.js"
  integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
  crossorigin="anonymous"></script>

  </head>
  <body class="td-page td-blog">
    <header>
      
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar">
        <a class="navbar-brand" href="/">
		<span class="navbar-logo"></span><span class="text-uppercase font-weight-bold">redis-docs</span>
	</a>
	<div class="td-navbar-nav-scroll ml-md-auto" id="main_navbar">
		<ul class="navbar-nav mt-2 mt-lg-0">
			
			
			<li class="nav-item mr-4 mb-2 mb-lg-0">
				
				
				
				
				
				
				
				
				<a class="nav-link" href="/docs/" ><span>文档</span></a>
			</li>
			
			<li class="nav-item mr-4 mb-2 mb-lg-0">
				
				
				
				
				
				
				
				
				<a class="nav-link active" href="/blog/" ><span class="active">博客</span></a>
			</li>
			
			
			
		</ul>
	</div>
	<div class="navbar-nav d-none d-lg-block"></div>
</nav>

    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <aside class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
            
<div id="td-sidebar-menu" class="td-sidebar__inner">
  <form class="td-sidebar__search d-flex align-items-center">
    
    <button class="btn btn-link td-sidebar__toggle d-md-none p-0 ml-3 fas fa-bars" type="button" data-toggle="collapse" data-target="#td-section-nav" aria-controls="td-docs-nav" aria-expanded="false" aria-label="Toggle section navigation">
    </button>
  </form>
  <nav class="collapse td-sidebar-nav" id="td-section-nav">
    <ul class="td-sidebar-nav__section pr-md-3 ul-0">
      <li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id="m-blog-li">
  <a href="/blog/" class="align-left pl-0 td-sidebar-link td-sidebar-link__section tree-root" id="m-blog"><span class="">博客</span></a>
  <ul class="ul-1">
    <li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id="m-blognews-li">
  <a href="/blog/news/" class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id="m-blognews"><span class="">news</span></a>
  <ul class="ul-2 foldable">
    <li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id="m-blognewslua-li">
  <a href="/blog/news/lua/" class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id="m-blognewslua"><span class="">Lua News</span></a>
  <ul class="ul-3 foldable">
    <li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blognewslua2020-2021-li">
  <a href="/blog/news/lua/2020-2021/" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blognewslua2020-2021"><span class="">2020-2021 Lua News</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blognewslua2010-2019-li">
  <a href="/blog/news/lua/2010-2019/" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blognewslua2010-2019"><span class="">2010-2019 Lua News</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blognewslua2000-2009-li">
  <a href="/blog/news/lua/2000-2009/" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blognewslua2000-2009"><span class="">2000-2009 Lua News</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blognewslua1993-1999-li">
  <a href="/blog/news/lua/1993-1999/" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blognewslua1993-1999"><span class="">1993-1999 Lua News</span></a>
</li>
  </ul>
</li>
  </ul>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id="m-blogseckill-li">
  <a href="/blog/seckill/" class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id="m-blogseckill"><span class="">秒杀</span></a>
  <ul class="ul-2 foldable">
    <li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blogseckillredlock-system-awareness-li">
  <a href="/blog/seckill/redlock-system-awareness/" title="建立对分布式锁的系统认知 - 从 Redlock 开始" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blogseckillredlock-system-awareness"><span class="">分布式锁系统认知</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blogseckillimplementation-of-redis-distributed-lock-li">
  <a href="/blog/seckill/implementation-of-redis-distributed-lock/" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blogseckillimplementation-of-redis-distributed-lock"><span class="">Implementation of redis distributed lock</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blogseckillexample-li">
  <a href="/blog/seckill/example/" title="一个使用 Node.js 的 Redlock 示例，关于如何锁定一个Redis上的密钥对" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blogseckillexample"><span class="">Redlok 示例</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blogseckillreplace_setnx-li">
  <a href="/blog/seckill/replace_setnx/" title="Redis 使用 Lua 脚本替代 SETNX / DECR 保证原子性" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blogseckillreplace_setnx"><span class="">替代 SETNX/DECR</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blogseckillnodejs-case-li">
  <a href="/blog/seckill/nodejs-case/" title="Node.js 中实践基于 Redis 的分布式锁实现" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blogseckillnodejs-case"><span class="">分布式锁实现</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child active-path" id="m-blogseckillnodejs-redis-lua-li">
  <a href="/blog/seckill/nodejs-redis-lua/" title="Node.js 中实践 Redis Lua 脚本" class="align-left pl-0 active td-sidebar-link td-sidebar-link__page" id="m-blogseckillnodejs-redis-lua"><span class="td-sidebar-nav-active-item">Node.js Redis Lua</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blogseckillis_redlock_safe-li">
  <a href="/blog/seckill/is_redlock_safe/" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blogseckillis_redlock_safe"><span class="">Is Redlock safe?</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blogseckilldistlock-li">
  <a href="/blog/seckill/distlock/" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blogseckilldistlock"><span class="">Redis分布式锁</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blogseckillhow-to-do-distributed-locking-li">
  <a href="/blog/seckill/how-to-do-distributed-locking/" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blogseckillhow-to-do-distributed-locking"><span class="">How to do distributed locking</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blogseckillredis_lua-li">
  <a href="/blog/seckill/redis_lua/" title="Redis&#43;Lua 解决高并发场景抢购秒杀问题" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blogseckillredis_lua"><span class="">Redis&#43;Lua秒杀</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blogseckilldistlock-cn-li">
  <a href="/blog/seckill/distlock-cn/" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blogseckilldistlock-cn"><span class="">Redis分布式锁</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blogseckillaliyun-li">
  <a href="/blog/seckill/aliyun/" title="使用  搭建电商秒杀系统" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blogseckillaliyun"><span class="">Redis秒杀系统</span></a>
</li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-blogseckillredlock-controversy-li">
  <a href="/blog/seckill/redlock-controversy/" title="Redis Redlock 的争论" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id="m-blogseckillredlock-controversy"><span class="">Redlock 争论</span></a>
</li>
  </ul>
</li>
  </ul>
</li>
    </ul>
  </nav>
</div>

          </aside>
          <aside class="d-none d-xl-block col-xl-2 td-sidebar-toc d-print-none">
            
<div class="td-page-meta ml-2 pb-1 pt-2 mb-0">

</div>

            


<div class="td-toc"><nav id="TableOfContents">
  <ul>
    <li><a href="#redis-的两种-lua-脚本">Redis 的两种 Lua 脚本</a></li>
    <li><a href="#eval">EVAL</a>
      <ul>
        <li><a href="#eval-redis-控制台实践">EVAL Redis 控制台实践</a></li>
        <li><a href="#rediscall-vs-redispcall">redis.call VS redis.pcall</a></li>
        <li><a href="#eval-在-nodejs-中实现">EVAL 在 Node.js 中实现</a></li>
      </ul>
    </li>
    <li><a href="#evalsha">EVALSHA</a>
      <ul>
        <li></li>
        <li><a href="#evalsha-redis-控制台实践">EVALSHA Redis 控制台实践</a></li>
        <li><a href="#evalsha-在-nodejs-中实现">EVALSHA 在 Node.js 中实现</a></li>
      </ul>
    </li>
    <li><a href="#lua-脚本文件">Lua 脚本文件</a>
      <ul>
        <li><a href="#lua-文件">Lua 文件</a></li>
        <li><a href="#nodejs-中加载-lua-脚本文件">Node.js 中加载 Lua 脚本文件</a></li>
      </ul>
    </li>
  </ul>
</nav></div>



            

	
		



  
  

	
		



  
  

	

          </aside>
          <main class="col-12 col-md-9 col-xl-8 pl-md-5 pr-md-4" role="main">
            <a class="btn btn-lg -bg-orange td-rss-button d-none d-lg-block" href="http://example.org/blog/seckill/index.xml" target="_blank">
              RSS <i class="fa fa-rss ml-2 "></i>
            </a>
            
<div class="td-content">
	<h1>Node.js 中实践 Redis Lua 脚本</h1>
	
	<div class="td-byline mb-4">
		
		<time datetime="2019-11-10" class="text-muted">Sunday, November 10, 2019</time>
	</div>
	<header class="article-meta">
		
		
			
				


			
				


			
		
		
	</header>
	<blockquote>
<p><a href="https://cloud.tencent.com/developer/article/1536299">https://cloud.tencent.com/developer/article/1536299</a></p>
</blockquote>
<p>Lua 是一种轻量小巧的脚本语言，用标准 C 语言编写并以源代码形式开放，其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。
由于 Lua 语言具备原子性，其在执行的过程中不会被其它程序打断，对于并发下数据的一致性是有帮助的。</p>
<h2 id="redis-的两种-lua-脚本">Redis 的两种 Lua 脚本</h2>
<p>Redis 支持两种运行 Lua 脚本的方式，一种是直接在 Redis 中输入 Lua 代码，适合于一些简单的脚本。另一种方式是编写 Lua 脚本文件，适合于有逻辑运算的情况，Redis 使用 SHA1 算法支持对脚本签名和 Script Load 预先缓存，需要运行的时候通过签名返回的标识符即可。</p>
<p>下面会分别介绍如何应用 Redis 提供的 EVAL、EVALSHA 两个命令来实现对 Lua 脚本的应用，同时介绍一些在 Node.js 中该如何去应用 Redis 的 Lua 脚本。</p>
<h2 id="eval">EVAL</h2>
<p>Redis 2.6.0 版本开始，通过内置的 Lua 解释器，可以使用 EVAL 命令对 Lua 脚本进行求值</p>
<ul>
<li>script：执行的脚本</li>
<li>numkeys：指定键名参数个数</li>
<li>key：键名，可以多个（key1、key2），通过 KEYS[1] KEYS[2] 的形式访问</li>
<li>atg：键值，可以多个（val1、val2），通过 ARGS[1] ARGS[2] 的形式访问</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">EVAL script numkeys key <span style="color:#f92672">[</span>key ...<span style="color:#f92672">]</span> arg <span style="color:#f92672">[</span>arg ...<span style="color:#f92672">]</span>
</code></pre></div><h3 id="eval-redis-控制台实践">EVAL Redis 控制台实践</h3>
<p>按照上面命令格式，写一个实例如下，通过 KEYS[] 数组的形式访问 ARGV[]，这里下标是以 1 开始，KEYS[1] 对应的键名为 name1，ARGV[2] 对应的值为 val2</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">127.0.0.1:6379&gt; EVAL <span style="color:#e6db74">&#34;return redis.call(&#39;SET&#39;, KEYS[1], ARGV[2])&#34;</span> <span style="color:#ae81ff">2</span> name1 name2 val1 val2
OK
</code></pre></div><p>执行以上命令，通过 get 查看 name1 对应的值为 val2</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">127.0.0.1:6379&gt; get name1
<span style="color:#e6db74">&#34;val2&#34;</span>
</code></pre></div><p>注意：以上命令如果不使用 return 将会返回 (nil)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">127.0.0.1:6379&gt; EVAL <span style="color:#e6db74">&#34;redis.call(&#39;SET&#39;, KEYS[1], ARGV[2])&#34;</span> <span style="color:#ae81ff">2</span> name1 name2 val1 val2
<span style="color:#f92672">(</span>nil<span style="color:#f92672">)</span>
</code></pre></div><h3 id="rediscall-vs-redispcall">redis.call VS redis.pcall</h3>
<p>redis.call 和 redis.pcall 是两个不同的 Lua 函数来调用 redis 命令，
两个命令很类似，区别是如果 redis 命令中出现错误异常，
redis.call 会直接返回一个错误信息给调用者，而 redis.pcall 会以 Lua 的形式对错误进行捕获并返回。</p>
<h4 id="使用-rediscall">使用 redis.call</h4>
<p>这里执行了两条 Redis 命令，第一条故意写了一个 SET_ 这是一个错误的命令，
可以看到出错后，错误信息被抛出给了调用者，同时你执行 get name2 会得到 (nil)，第二条命令也没有被执行</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">127.0.0.1:6379&gt; EVAL <span style="color:#e6db74">&#34;redis.call(&#39;SET_&#39;, KEYS[1], ARGV[2]); redis.call(&#39;SET&#39;, KEYS[2], ARGV[3])&#34;</span> <span style="color:#ae81ff">2</span> name1 name2 val1 val2 val3
<span style="color:#f92672">(</span>error<span style="color:#f92672">)</span> ERR Error running script <span style="color:#f92672">(</span>call to f_bf814e38e3d98242ae0c62791fa299f04e757a7d<span style="color:#f92672">)</span>: @user_script:1: @user_script: 1: Unknown Redis command called from Lua script
</code></pre></div><h4 id="使用-redispcall">使用 redis.pcall</h4>
<p>和上面同样的操作，使用 redis.pcall 可以看到输出结果为 (nil) 它的错误被 Lua 捕获了，这时我们在执行 get name2 会得到一个设置好的结果 val3，这里第二条命令是被执行了的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">EVAL <span style="color:#e6db74">&#34;redis.pcall(&#39;SET_&#39;, KEYS[1], ARGV[2]); redis.pcall(&#39;SET&#39;, KEYS[2], ARGV[3])&#34;</span> <span style="color:#ae81ff">2</span> name1 name2 val1 val2 val3
<span style="color:#f92672">(</span>nil<span style="color:#f92672">)</span>
</code></pre></div><h3 id="eval-在-nodejs-中实现">EVAL 在 Node.js 中实现</h3>
<p>ioredis 支持所有的脚本命令，比如 EVAL、EVALSHA 和 SCRIPT。但是，在现实场景中使用它是很繁琐的，
因为开发人员必须注意脚本缓存，并检测何时使用 EVAL，何时使用 EVALSHA。
ioredis 公开了一个 defineCommand 方法，使脚本更容易使用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">const Redis <span style="color:#f92672">=</span> require<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;ioredis&#34;</span><span style="color:#f92672">)</span>;
const redis <span style="color:#f92672">=</span> new Redis<span style="color:#f92672">(</span>6379, <span style="color:#e6db74">&#34;127.0.0.1&#34;</span><span style="color:#f92672">)</span>;

const evalScript <span style="color:#f92672">=</span> <span style="color:#e6db74">`</span><span style="color:#66d9ef">return</span> redis.call<span style="color:#f92672">(</span><span style="color:#e6db74">&#39;SET&#39;</span>, KEYS<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>, ARGV<span style="color:#f92672">[</span>2<span style="color:#f92672">])</span><span style="color:#e6db74">`</span>;

redis.defineCommand<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;evalTest&#34;</span>, <span style="color:#f92672">{</span>
    numberOfKeys: 2,
    lua: evalScript,
<span style="color:#f92672">})</span>

async <span style="color:#66d9ef">function</span> eval<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    await redis.evalTest<span style="color:#f92672">(</span><span style="color:#e6db74">&#39;name1&#39;</span>, <span style="color:#e6db74">&#39;name2&#39;</span>, <span style="color:#e6db74">&#39;val1&#39;</span>, <span style="color:#e6db74">&#39;val2&#39;</span><span style="color:#f92672">)</span>;
    const result <span style="color:#f92672">=</span> await redis.get<span style="color:#f92672">(</span><span style="color:#e6db74">&#39;name1&#39;</span><span style="color:#f92672">)</span>;
    console.log<span style="color:#f92672">(</span>result<span style="color:#f92672">)</span>; // val2
<span style="color:#f92672">}</span>

eval<span style="color:#f92672">()</span>;
</code></pre></div><h2 id="evalsha">EVALSHA</h2>
<p>EVAL 命令要求你在每次执行脚本的时候都发送一次脚本主体 (script body)。
Redis 有一个内部的缓存机制，因此它不会每次都重新编译脚本，通过 EVALSHA 来实现，根据给定的 SHA1 校验码，对缓存在服务器中的脚本进行求值。
SHA1 怎么生成呢？通过 script 命令，可以对脚本缓存进行操作</p>
<ul>
<li>SCRIPT FLUSH：清除所有脚本缓存</li>
<li>SCRIPT EXISTS：检查指定的脚本是否存在于脚本缓存</li>
<li>SCRIPT LOAD：将一个脚本装入脚本缓存，但并不立即运行它</li>
<li>SCRIPT KILL：杀死当前正在运行的脚本</li>
</ul>
<h4 id="evalsha-命令格式">EVALSHA 命令格式</h4>
<p>同上面 EVAL 不同的是前面 EVAL script 换成了 EVALSHA sha1</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">EVALSHA sha1 numkeys key <span style="color:#f92672">[</span>key ...<span style="color:#f92672">]</span> arg <span style="color:#f92672">[</span>arg ...<span style="color:#f92672">]</span>
</code></pre></div><h3 id="evalsha-redis-控制台实践">EVALSHA Redis 控制台实践</h3>
<p>载入脚本缓存</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">127.0.0.1:6379&gt; SCRIPT LOAD <span style="color:#e6db74">&#34;redis.pcall(&#39;SET&#39;, KEYS[1], ARGV[2]);&#34;</span>
<span style="color:#e6db74">&#34;2a3b189808b36be907e26dab7ddcd8428dcd1bc8&#34;</span>
</code></pre></div><p>以上脚本执行之后会返回一个 SHA-1 签名过后的标识字符串，这个字符串用于下面命令执行签名之后的脚本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">127.0.0.1:6379&gt; EVALSHA 2a3b189808b36be907e26dab7ddcd8428dcd1bc8 <span style="color:#ae81ff">2</span> name1 name2 val1 val2
</code></pre></div><p>进行 get 操作读取 name1 的只为 val2</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">127.0.0.1:6379&gt; get name1
<span style="color:#e6db74">&#34;val2&#34;</span>
</code></pre></div><h3 id="evalsha-在-nodejs-中实现">EVALSHA 在 Node.js 中实现</h3>
<p>分为三步：缓存脚本、执行脚本、获取数据</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">Redis</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#34;ioredis&#34;</span>);
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">redis</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Redis</span>(<span style="color:#ae81ff">6379</span>, <span style="color:#e6db74">&#34;127.0.0.1&#34;</span>);

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">evalScript</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">`return redis.call(&#39;SET&#39;, KEYS[1], ARGV[2])`</span>;

<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">evalSHA</span>() {
  <span style="color:#75715e">// 1. 缓存脚本获取 sha1 值
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">sha1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">redis</span>.<span style="color:#a6e22e">script</span>(<span style="color:#e6db74">&#34;load&#34;</span>, <span style="color:#a6e22e">evalScript</span>);
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">sha1</span>); <span style="color:#75715e">// 6bce4ade07396ba3eb2d98e461167563a868c661
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// 2. 通过 evalsha 执行脚本
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">redis</span>.<span style="color:#a6e22e">evalsha</span>(<span style="color:#a6e22e">sha1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;name1&#34;</span>, <span style="color:#e6db74">&#34;name2&#34;</span>, <span style="color:#e6db74">&#34;val1&#34;</span>, <span style="color:#e6db74">&#34;val2&#34;</span>);

  <span style="color:#75715e">// 3. 获取数据
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">redis</span>.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;name1&#34;</span>);
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">result</span>); <span style="color:#75715e">// &#34;val2&#34;
</span><span style="color:#75715e"></span>}

<span style="color:#a6e22e">evalSHA</span>();
</code></pre></div><h2 id="lua-脚本文件">Lua 脚本文件</h2>
<p>有逻辑运算的脚本，可以编写 Lua 脚本文件，编写一些简单的脚本也不难，可以参考这个教程 <a href="https://www.runoob.com/lua/lua-tutorial.html">https://www.runoob.com/lua/lua-tutorial.html</a></p>
<h3 id="lua-文件">Lua 文件</h3>
<p>以下是一个测试代码，通过读取两个值比较返回不同的值，通过 Lua 脚本实现后可以多条 Redis 命令的原子性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#75715e">-- test.lua</span>

<span style="color:#75715e">-- 先 SET</span>
redis.call(<span style="color:#e6db74">&#34;SET&#34;</span>, KEYS[<span style="color:#ae81ff">1</span>], ARGV[<span style="color:#ae81ff">1</span>])
redis.call(<span style="color:#e6db74">&#34;SET&#34;</span>, KEYS[<span style="color:#ae81ff">2</span>], ARGV[<span style="color:#ae81ff">2</span>])

<span style="color:#75715e">-- GET 取值</span>
<span style="color:#66d9ef">local</span> key1 <span style="color:#f92672">=</span> tonumber(redis.call(<span style="color:#e6db74">&#34;GET&#34;</span>, KEYS[<span style="color:#ae81ff">1</span>]))
<span style="color:#66d9ef">local</span> key2 <span style="color:#f92672">=</span> tonumber(redis.call(<span style="color:#e6db74">&#34;GET&#34;</span>, KEYS[<span style="color:#ae81ff">2</span>]))

<span style="color:#75715e">-- 如果 key1 小于 key2 返回 0</span>
<span style="color:#75715e">-- nil 相当于 false</span>
<span style="color:#66d9ef">if</span> (key1 <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">or</span> key2 <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">or</span> key1 <span style="color:#f92672">&lt;</span> key2) <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
<span style="color:#66d9ef">else</span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><h3 id="nodejs-中加载-lua-脚本文件">Node.js 中加载 Lua 脚本文件</h3>
<p>和上面 Node.js 中应用 Lua 差别不大，多了一步，通过 fs 模块先读取 Lua 脚本文件，在通过 eval 或者 evalsha 执行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">Redis</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#34;ioredis&#34;</span>);
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">redis</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Redis</span>(<span style="color:#ae81ff">6379</span>, <span style="color:#e6db74">&#34;127.0.0.1&#34;</span>);
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fs</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#34;fs&#34;</span>);

<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">test</span>() {
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">redisLuaScript</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">fs</span>.<span style="color:#a6e22e">readFileSync</span>(<span style="color:#e6db74">&#34;./test.lua&#34;</span>);
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">result1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">redis</span>.eval(<span style="color:#a6e22e">redisLuaScript</span>, <span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;name1&#34;</span>, <span style="color:#e6db74">&#34;name2&#34;</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">10</span>);
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">result2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">redis</span>.eval(<span style="color:#a6e22e">redisLuaScript</span>, <span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;name1&#34;</span>, <span style="color:#e6db74">&#34;name2&#34;</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>);
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">result1</span>, <span style="color:#a6e22e">result2</span>); <span style="color:#75715e">// 1 0
</span><span style="color:#75715e"></span>}

<span style="color:#a6e22e">test</span>();
</code></pre></div>
	

	<ul class="list-unstyled d-flex justify-content-between align-items-center mb-0 pt-5">
  <li>
    <a href="/blog/seckill/is_redlock_safe/" aria-label="Previous - Is Redlock safe?" class="btn btn-primary"><span class="mr-1">←</span>Previous</a>
  </li>
    <a href="/blog/seckill/nodejs-case/" aria-label="Next - Node.js 中实践基于 Redis 的分布式锁实现" class="btn btn-primary">Next<span class="ml-1">→</span></a>
  </li>
</ul>

</div>


          </main>
        </div>
      </div>
      
<footer class="bg-dark py-5 row d-print-none">
  <div class="container-fluid mx-sm-5">
    <div class="row">
      <div class="col-6 col-sm-4 text-xs-center order-sm-2">
        
      </div>
      <div class="col-6 col-sm-4 text-right text-xs-center order-sm-3">
        
      </div>
      <div class="col-12 col-sm-4 text-center py-2 order-sm-2">
        
        
	
		<p class="mt-2"><a href="/docs/lua/about/">关于</a></p>
	
      </div>
    </div>
  </div>
</footer>


    </div>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"
    integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN"
    crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js"
    integrity="sha512-UR25UO94eTnCVwjbXozyeVd6ZqpaAE9naiEUBK/A+QDbfSTQFhPGj5lOR6d8tsgbBk84Ggb5A3EkjsOgPRPcKA=="
    crossorigin="anonymous"></script>





<script src='/js/tabpane-persist.js'></script>


















<script src="/js/main.min.5c6c35925cba6ccdfc94d3ef0a1ff539934a08075c0931f2c9ab70249877b310.js" integrity="sha256-XGw1kly6bM38lNPvCh/1OZNKCAdcCTHyyatwJJh3sxA=" crossorigin="anonymous"></script>




  </body>
</html>